// This file was generated based on '(multiple files)'.
// WARNING: Changes might be lost if you edit this file directly.

#include <Uno.ArgumentException.h>
#include <Uno.ArgumentNullException.h>
#include <Uno.Bool.h>
#include <Uno.Byte.h>
#include <Uno.Exception.h>
#include <Uno.Graphics.Format.h>
#include <Uno.Graphics.FormatHelpers.h>
#include <Uno.Graphics.Texture2D.h>
#include <Uno.Graphics.Utils.Bitmap.h>
#include <Uno.Graphics.Utils.Cp-4d8fcd80.h>
#include <Uno.Graphics.Utils.Cp-81b1e966.h>
#include <Uno.Graphics.Utils.FontLoader.h>
#include <Uno.Graphics.Utils.Te-932dbf58.h>
#include <Uno.Graphics.Utils.Te-f6eb538b.h>
#include <Uno.Int.h>
#include <Uno.IO.BundleFile.h>
#include <Uno.String.h>
static uString* STRINGS[7];
static uType* TYPES[2];

namespace g{
namespace Uno{
namespace Graphics{
namespace Utils{

// /Users/morten/fuse-open/fuselibs/node_modules/@fuse-open/uno/lib/build/Uno.Graphics.Utils/2.2.0/Bitmap.uno
// ----------------------------------------------------------------------------------------------------------

// public sealed class Bitmap
// {
static void Bitmap_build(uType* type)
{
    ::STRINGS[0] = uString::Const("size");
    ::STRINGS[1] = uString::Const("Cannot be negative");
    ::STRINGS[2] = uString::Const("optionalData");
    ::STRINGS[3] = uString::Const("Invalid buffer size");
    ::TYPES[0] = ::g::Uno::Byte_typeof()->Array();
    type->SetFields(0,
        ::TYPES[0/*byte[]*/], offsetof(Bitmap, _Data), 0,
        ::g::Uno::Graphics::Format_typeof(), offsetof(Bitmap, _Format), 0,
        ::g::Uno::Int2_typeof(), offsetof(Bitmap, _Size), 0);
}

uType* Bitmap_typeof()
{
    static uSStrong<uType*> type;
    if (type != nullptr) return type;

    uTypeOptions options;
    options.FieldCount = 3;
    options.ObjectSize = sizeof(Bitmap);
    options.TypeSize = sizeof(uType);
    type = uClassType::New("Uno.Graphics.Utils.Bitmap", options);
    type->fp_build_ = Bitmap_build;
    return type;
}

// public Bitmap(int2 size, Uno.Graphics.Format format, [byte[] optionalData])
void Bitmap__ctor__fn(Bitmap* __this, ::g::Uno::Int2* size, int32_t* format, uArray* optionalData)
{
    __this->ctor_(*size, *format, optionalData);
}

// public generated byte[] get_Data()
void Bitmap__get_Data_fn(Bitmap* __this, uArray** __retval)
{
    *__retval = __this->Data();
}

// private generated void set_Data(byte[] value)
void Bitmap__set_Data_fn(Bitmap* __this, uArray* value)
{
    __this->Data(value);
}

// public generated Uno.Graphics.Format get_Format()
void Bitmap__get_Format_fn(Bitmap* __this, int32_t* __retval)
{
    *__retval = __this->Format();
}

// private generated void set_Format(Uno.Graphics.Format value)
void Bitmap__set_Format_fn(Bitmap* __this, int32_t* value)
{
    __this->Format(*value);
}

// public Bitmap New(int2 size, Uno.Graphics.Format format, [byte[] optionalData])
void Bitmap__New1_fn(::g::Uno::Int2* size, int32_t* format, uArray* optionalData, Bitmap** __retval)
{
    *__retval = Bitmap::New1(*size, *format, optionalData);
}

// public generated int2 get_Size()
void Bitmap__get_Size_fn(Bitmap* __this, ::g::Uno::Int2* __retval)
{
    *__retval = __this->Size();
}

// private generated void set_Size(int2 value)
void Bitmap__set_Size_fn(Bitmap* __this, ::g::Uno::Int2* value)
{
    __this->Size(*value);
}

// public Bitmap(int2 size, Uno.Graphics.Format format, [byte[] optionalData]) [instance]
void Bitmap::ctor_(::g::Uno::Int2 size, int32_t format, uArray* optionalData)
{
    Size(size);
    Format(format);
    int32_t bpp = ::g::Uno::Graphics::FormatHelpers::GetStrideInBytes(Format());
    int32_t byteCount = (Size().X * Size().Y) * bpp;

    if (byteCount < 0)
        U_THROW(::g::Uno::ArgumentException::New5(::STRINGS[0/*"size"*/], ::STRINGS[1/*"Cannot be n...*/]));

    if (optionalData != nullptr)
    {
        if (uPtr(optionalData)->Length() != byteCount)
            U_THROW(::g::Uno::ArgumentException::New5(::STRINGS[2/*"optionalData"*/], ::STRINGS[3/*"Invalid buf...*/]));

        Data(optionalData);
    }
    else
        Data(uArray::New(::TYPES[0/*byte[]*/], byteCount));
}

// public generated byte[] get_Data() [instance]
uArray* Bitmap::Data()
{
    return _Data;
}

// private generated void set_Data(byte[] value) [instance]
void Bitmap::Data(uArray* value)
{
    _Data = value;
}

// public generated Uno.Graphics.Format get_Format() [instance]
int32_t Bitmap::Format()
{
    return _Format;
}

// private generated void set_Format(Uno.Graphics.Format value) [instance]
void Bitmap::Format(int32_t value)
{
    _Format = value;
}

// public generated int2 get_Size() [instance]
::g::Uno::Int2 Bitmap::Size()
{
    return _Size;
}

// private generated void set_Size(int2 value) [instance]
void Bitmap::Size(::g::Uno::Int2 value)
{
    _Size = value;
}

// public Bitmap New(int2 size, Uno.Graphics.Format format, [byte[] optionalData]) [static]
Bitmap* Bitmap::New1(::g::Uno::Int2 size, int32_t format, uArray* optionalData)
{
    Bitmap* obj1 = (Bitmap*)uNew(Bitmap_typeof());
    obj1->ctor_(size, format, optionalData);
    return obj1;
}
// }

// /Users/morten/fuse-open/fuselibs/node_modules/@fuse-open/uno/lib/build/Uno.Graphics.Utils/2.2.0/FontLoader.uno
// --------------------------------------------------------------------------------------------------------------

// public static class FontLoader
// {
static void FontLoader_build(uType* type)
{
    ::STRINGS[4] = uString::Const("data");
    ::STRINGS[5] = uString::Const("file");
}

uClassType* FontLoader_typeof()
{
    static uSStrong<uClassType*> type;
    if (type != nullptr) return type;

    uTypeOptions options;
    options.TypeSize = sizeof(uClassType);
    type = uClassType::New("Uno.Graphics.Utils.FontLoader", options);
    type->fp_build_ = FontLoader_build;
    return type;
}

// public static Uno.Graphics.Utils.Text.FontFace LoadFace(byte[] data)
void FontLoader__LoadFace_fn(uArray* data, ::g::Uno::Graphics::Utils::Text::FontFace** __retval)
{
    *__retval = FontLoader::LoadFace(data);
}

// public static Uno.Graphics.Utils.Text.FontFace LoadFace(Uno.IO.BundleFile file)
void FontLoader__LoadFace1_fn(::g::Uno::IO::BundleFile* file, ::g::Uno::Graphics::Utils::Text::FontFace** __retval)
{
    *__retval = FontLoader::LoadFace1(file);
}

// public static Uno.Graphics.Utils.Text.FontFace LoadFace(byte[] data) [static]
::g::Uno::Graphics::Utils::Text::FontFace* FontLoader::LoadFace(uArray* data)
{
    if (data == nullptr)
        U_THROW(::g::Uno::ArgumentNullException::New6(::STRINGS[4/*"data"*/]));

    return ::g::Uno::Graphics::Utils::Cpp::CppFontFace::New1(data, 0, uPtr(data)->Length());
}

// public static Uno.Graphics.Utils.Text.FontFace LoadFace(Uno.IO.BundleFile file) [static]
::g::Uno::Graphics::Utils::Text::FontFace* FontLoader::LoadFace1(::g::Uno::IO::BundleFile* file)
{
    if (file == nullptr)
        U_THROW(::g::Uno::ArgumentNullException::New6(::STRINGS[5/*"file"*/]));

    return ::g::Uno::Graphics::Utils::Cpp::CppFontFace::New2(file);
}
// }

// /Users/morten/fuse-open/fuselibs/node_modules/@fuse-open/uno/lib/build/Uno.Graphics.Utils/2.2.0/TextureLoader.uno
// -----------------------------------------------------------------------------------------------------------------

// public static class TextureLoader
// {
static void TextureLoader_build(uType* type)
{
    ::STRINGS[6] = uString::Const(".png");
    ::TYPES[1] = ::g::Uno::Exception_typeof();
}

uClassType* TextureLoader_typeof()
{
    static uSStrong<uClassType*> type;
    if (type != nullptr) return type;

    uTypeOptions options;
    options.TypeSize = sizeof(uClassType);
    type = uClassType::New("Uno.Graphics.Utils.TextureLoader", options);
    type->fp_build_ = TextureLoader_build;
    return type;
}

// public static texture2D Load2D(string filename, byte[] bytes)
void TextureLoader__Load2D1_fn(uString* filename, uArray* bytes, ::g::Uno::Graphics::Texture2D** __retval)
{
    *__retval = TextureLoader::Load2D1(filename, bytes);
}

// internal static texture2D Load2DJpeg(byte[] bytes)
void TextureLoader__Load2DJpeg_fn(uArray* bytes, ::g::Uno::Graphics::Texture2D** __retval)
{
    *__retval = TextureLoader::Load2DJpeg(bytes);
}

// internal static texture2D Load2DPng(byte[] bytes)
void TextureLoader__Load2DPng_fn(uArray* bytes, ::g::Uno::Graphics::Texture2D** __retval)
{
    *__retval = TextureLoader::Load2DPng(bytes);
}

// public static texture2D Load2D(string filename, byte[] bytes) [static]
::g::Uno::Graphics::Texture2D* TextureLoader::Load2D1(uString* filename, uArray* bytes)
{
    filename = ::g::Uno::String::ToLower(uPtr(filename));

    if (::g::Uno::String::EndsWith(filename, ::STRINGS[6/*".png"*/]))
        return TextureLoader::Load2DPng(bytes);
    else
        return TextureLoader::Load2DJpeg(bytes);
}

// internal static texture2D Load2DJpeg(byte[] bytes) [static]
::g::Uno::Graphics::Texture2D* TextureLoader::Load2DJpeg(uArray* bytes)
{
    try
    {
        {
            return ::g::Uno::Graphics::Utils::Cpp::CppTexture::Load2DJpeg(bytes);
        }
    }

    catch (const uThrowable& __t)
    {
        ::g::Uno::Exception* jpegException = __t.Exception;

        try
        {
            {
                return ::g::Uno::Graphics::Utils::Cpp::CppTexture::Load2DPng(bytes);
            }
        }

        catch (const uThrowable& __t)
        {
            ::g::Uno::Exception* pngException = __t.Exception;
            U_THROW(jpegException);
        }
    }
}

// internal static texture2D Load2DPng(byte[] bytes) [static]
::g::Uno::Graphics::Texture2D* TextureLoader::Load2DPng(uArray* bytes)
{
    try
    {
        {
            return ::g::Uno::Graphics::Utils::Cpp::CppTexture::Load2DPng(bytes);
        }
    }

    catch (const uThrowable& __t)
    {
        ::g::Uno::Exception* pngException = __t.Exception;

        try
        {
            {
                return ::g::Uno::Graphics::Utils::Cpp::CppTexture::Load2DJpeg(bytes);
            }
        }

        catch (const uThrowable& __t)
        {
            ::g::Uno::Exception* jpegException = __t.Exception;
            U_THROW(pngException);
        }
    }
}
// }

}}}} // ::g::Uno::Graphics::Utils
